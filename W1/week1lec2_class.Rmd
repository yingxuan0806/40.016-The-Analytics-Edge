---
title: 'Basic R Notebook: Lecture 2'
output:
  pdf_document: default
  html_notebook: default
  html_document: default
---


R stores objects in a variety of classes - numeric, integer, character, logical, list, matrix, dataframe and has logical overriding operations when you convert from one class to another.
```{r}
z <- 0:9
z
class(z) # integer
typeof(z)
str(z)

```
```{r}
z1 <- c("a", "b")
z1
class(z1) # character
typeof(z1)
str(z1)

```
```{r}
w <- as.character(z)
w
class(w) # character

```
```{r}
as.integer(w)

as.logical(c(5, 0))
# TRUE FALSE 
# converts all non-zero values to TRUE, 0 to FALSE

```
```{r}
z
z > 1
as.numeric(z > 1)
# false is zero, true is 1
```

```{r}
w1 <- c(1, "a")
w1
class(w1) # character
```
```{r}
# shortform for TRUE and FALSE
T
F
```


Factors: 
```{r}
ct <- c("jap", "kor", "sin", "kor", "jap", "sin", "sin")
class(ct) # character

# factor function is used to identify identical values to belong to one category
# such that we can know how many levels (ie. different cities) in the ct vector
# ie. returns all the different categories
fct <- as.factor(ct)

levels(fct)
# returns "jap" "kor" "sin"

summary(fct)
# jap kor sin 
#   2   2   3 

table(fct) # alternative command for summary()
# table and summary give the same results returned

```


The function tapply:

- to categorise dataset into groups (factors)

- within each group, apply a function
```{r}
# tapply(vector, index, function)
income <- c(500, 1000, 4000, 1244, 3400, 2000, 5000)
mean(income) 
# returns mean over all values in the vector

# take the object income to 
tapply(income, fct, mean)
# index: according to what parameter/category to use the function
# returns
#     jap      kor      sin 
# 1950.000 1122.000 3666.667

```

```{r}
# rnorm(n = no_of_obs, mean = 0, sd = 1)
# generates random values based on the specified normal distribution

# gl(n = no_of_levels, k = no_of_replications_per_level)
# generates factor levels
med <- data.frame(patient = 1:100, age = rnorm(100, mean = 60, sd = 12), treatment = gl(2, 50, labels = c("treatment", "control")))
head(med)
```

```{r}
# mean age across treatment groups
tapply(med$age, med$treatment, mean)
```

Matrix and arrays

Matrix operations:
```{r}
r <- matrix(c(3:8), nrow = 3, ncol = 2, byrow = F)
# filled up column-wise
r

```

```{r}
# get matrix dimensions: returns row and column
dim(r) # 3 2

r[2,2] # 7 [row, column]
r[5] # 7 - indexing still reads column wise, so the 5th element of input into the matrix
r[1,] # 3 6 [row, column]

class(r) # "matrix" "array"

rownames(r)<- c("A", "B", "C") # specify/add row names
colnames(r) <- c("a", "a")

rownames(r) # returns all row names

r

```


Array operations:
```{r}
a <- array(c(3:8), c(3, 2)) # values to input, c(no_of_rows, no_of_cols)
a
class(a) # "matrix" "array"

```
```{r}
z <- 1:50
dim(z) <- c(5, 2, 5)
z
```

```{r}
z[5,2,5]
```

```{r}
z[5,2,1:5]
class(z)
```



Other operations with matrices:
```{r}
# to get diagonal matrix where the diagonals are filled with 1 and remaining filled with 0
diag(10)
```

```{r}
# state the specific values to fill in the diagonals, and the remaining filled with 0
diag(c(5, 3, 2))

```

```{r}
# alternative way to create a matrix
# row fill
# gives 2 rows, 3 columns
rbind(c(1, 2, 3), c(4, 5, 6))
#      [,1] [,2] [,3]
# [1,]    1    2    3
# [2,]    4    5    6

# column fill
# gives 3 rows, 2 columns
cbind(c(1, 2, 3), c(4, 5, 6))
#      [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6

```



Matrix multiplication:
```{r}
# matrix element-wise multiplication
# the two matrices must be of the same dimensions
# else, error: non-conformable arrays
x <- matrix(5:10, nrow = 3, ncol = 2)
x
```

```{r}
y <- matrix(1:6, nrow = 3, ncol = 2)
y
```

```{r}
x*y # element wise multiplication

# if a matrix is multiplied by a scalar value, every element in the matrix will be multiplied by the scalar

```


```{r}
# Multiplying matrix with vector 
# the vector will then be promoted into a row or column matrix to make the two arguments conformable
m <- matrix(1:8, nrow=2)    
vec <- 1:2

# matrix m
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8

print(vec*m) 
# result
# 1*1=1   1*3=3   1*5=5   1*7=7
# 2*2=4   2*4=8   2*6=12  2*8=16

# first row multiplied by 1
# second row multiplied by 2

#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    4    8   12   16
  



# multiplies two matrices if they are conformable (matrix multiplication)
help("%*%")

# number of columns in first matrix must equal to the number of rows in the second matrix
# resulting matrix will be number of rows from the first matrix, number of columns from the second matrix
# (m x n) %*% (n x k) = (m x k)
# else, error: non-conformable arrays

# t(x) transpose matrix function
x %*% t(y)
```



Solutions of linear equations:
```{r}
# ax = b
# a: coefficients of the equation
# b: vector or matrix of the equation (ie. RHS values)
a <- array(c(2, 1, -1, 2), c(2, 2))
a

```

```{r}
b <- c(4, 4)
b

```

```{r}
solve(a, b)
```

```{r}
# if b is not specified, takes b as an identity matrix and solve it
# ie. resulting solution is the inverse matrix of a
solve(a)
```




Eigen decomposition of a matrix:
```{r}
a <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)
a
eigen(a) # a: matrix

```

```{r}
# eigenvalue is the factor by which a eigenvector is scaled
E <- eigen(a)
E$values
E$vectors
```




List consists of an ordered collection of objects that can be of different or the same type.
```{r}
barack <- list(age = 59, sex = "M", child.ages = c(22, 19))
barack
class(barack) # list
```

```{r}


# accessing elements in the list

barack$age
barack[1] # age value: 59 - first list element
barack$child.ages
barack$child.ages[1]
barack[[1]] # 59 first component of the first list element

class(barack[1]) 
class(barack[[1]]) 
# numeric

# [ ] and [[ ]] are different in a way that [[ ]] will only return a single element via indexing using integer or character
# while [ ] allows for indexing by vectors
# both still returns a single element
```
```{r}
serena <- list(age = 39, sex = "F", child.ages = 3)
serena
class(serena) # list
```

```{r}
celg <- c(barack, serena) # joins both lists together, elements with the same name would not combine together
celg
```

```{r}
celg$sex # only the first list element will be returned if there are two elements of the same name
celg[1] # first element in the celg list
celg[3]
celg[4]
```


Dataframes are a tightly coupled collection of variables that share many of the properties of matrices and lists and is the fundamental data structure that will be used in most of this course.
```{r}
A <- data.frame(names = c("barack", "serena"), ages = c(58, 39), children = c(2, 1))
A

```

```{r}
A$names
class(A) # dataframe
class(A$ages) # numeric

```

```{r}
# add new column
A$spouse = c("michel", "alexis")
A
```



Dyplr and tibble ... not covered now but good to know

```{r}
library(tidyverse)
starwars
class(starwars)

# $>$ is pipe
starwars %>% dim()
# equivalent to dim(starwars)
# starwars %>% summary()

starwars %>% select(mass) %>% summary()

starwars %>% filter(sex=="female")


starwars %>% arrange(height,mass)

starwars %>% arrange(desc(height))

starwars %>% slice_head(n=3)

```
