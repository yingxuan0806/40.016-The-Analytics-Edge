---
title: 'Basic R Notebook: Lecture 2'
output:
  pdf_document: default
  html_notebook: default
  html_document: default
---


R stores objects in a variety of classes - numeric, integer, character, logical, list, matrix, dataframe and has logical overriding operations when you convert from one class to another.
```{r}
z <- 0:9
z
class(z) # integer
typeof(z)
str(z)

z1 <- c("a", "b")
z1
class(z1) # character
typeof(z1)
str(z1)

w <- as.character(z)
w
class(w) # character

as.integer(w)

as.logical(c(5, 0))
# TRUE FALSE 
# converts all non-zero values to TRUE, 0 to FALSE

z > 1
as.numeric(z > 1)


w1 <- c(1, "a")
w1
class(w1) # character

# shortform for TRUE and FALSE
T
F

```


Factors: 
```{r}
ct <- c("jap", "kor", "sin", "kor", "jap", "sin", "sin")
class(ct) # character

# factor function is used to identify identical values to belong to one category
# such that we can know how many levels (ie. different cities) in the ct vector
fct <- as.factor(ct)

levels(fct)
# returns "jap" "kor" "sin"

summary(fct)
# jap kor sin 
#   2   2   3 

table(fct) # alternative command for summary()
# table and summary give the same results returned

```


The function tapply:
```{r}
# to categorise dataset into groups (factors)
# within each group, apply a function
# tapply(vector, index, function)
income <- c(500, 1000, 4000, 1244, 3400, 2000, 5000)
mean(income) 
# returns mean over all values in the vector

# take the object income to 
tapply(income, fct, mean)
# index: according to what parameter/category to use the function
# returns
#     jap      kor      sin 
# 1950.000 1122.000 3666.667

med <- data.frame(patient = 1:100, age = rnorm(100, mean = 60, sd = 12), treatment = gl(2, 50, labels = c("treatment", "control")))
head(med)

tapply(med$age, med$treatment, mean)
```

Matrix and arrays

Matrix operations:
```{r}
r <- matrix(c(3:8), nrow = 3, ncol = 2, byrow = F)
# filled up column-wise
r

# get matrix dimensions: returns row and column
dim(r)

r[2,2]
r[5] # indexing still reads column wise, so the 5th element of input into the matrix
r[1,]

class(r) # "matrix" "array"

rownames(r)<- c("A", "B", "C") # specify/add row names
colnames(r) <- c("a", "a")

rownames(r) # returns all row names

r
```


Array operations:
```{r}
a <- array(c(3:8), c(3, 2)) # values to input, c(no_of_rows, no_of_cols)
a
class(a) # "matrix" "array"

z <- 1:50
dim(z) <- c(5, 2, 5)
z

z[5,2,5]
z[5,2,1:5]

class(z)
```

Other operations with matrices:
```{r}
# to get diagonal matrix where the diagonals are filled with 1 and remaining filled with 0
diag(10)

# state the specific values to fill in the diagonals, and the remaining filled with 0
diag(c(5, 3, 2))


# alternative way to create a matrix
# row fill
# gives 2 rows, 3 columns
rbind(c(1, 2, 3), c(4, 5, 6))
#      [,1] [,2] [,3]
# [1,]    1    2    3
# [2,]    4    5    6

# column fill
# gives 3 rows, 2 columns
cbind(c(1, 2, 3), c(4, 5, 6))
#      [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6
```

Matrix multiplication:
```{r}

# matrix element-wise multiplication
# the two matrices must be of the same dimensions
# else, error: non-conformable arrays
x <- matrix(5:10, nrow = 3, ncol = 2)
y <- matrix(1:6, nrow = 3, ncol = 2)
x
y

x*y

# if a matrix is multiplied by a scalar value, every element in the matrix will be multiplied by the scalar




# Multiplying matrix with vector 
# the vector will then be promoted into a row or column matrix to make the two arguments conformable
m <- matrix(1:8, nrow=2)    
vec <- 1:2

# matrix m
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    4    8   12   16

print(vec*m) 
# result
# 1*1=1   1*3=3   1*5=5   1*7=7
# 2*2=4   2*4=8   2*6=12  2*8=16

#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    4    8   12   16
  



# multiplies two matrices if they are conformable (matrix multiplication)
help("%*%")

# number of columns in first matrix must equal to the number of rows in the second matrix
# resulting matrix will be number of rows from the first matrix, number of columns from the second matrix
# (m x n) . (n x k) = (m x k)
# else, error: non-conformable arrays

# t(x) is a transpose function for matrix or dataframe
x %*% t(y)
```



Solutions of linear equations:
```{r}
# ax = b
# a: coefficients of the equation
# b: vector or matrix of the equation
a <- array(c(2, 1, -1, 2), c(2, 2))
b <- c(4, 4)

a
b

solve(a, b)

# if b is not specified, takes b as an identity matrix and solve it
# ie. resulting solution is the inverse matrix of a
solve(a)

```

Eigen decomposition of a matrix:
```{r}
a
eigen(a) # a: matrix
E <- eigen(a)

# eigenvalue is the factor by which a eigenvector is scaled
E$values
E$vectors
```



List consists of an ordered collection of objects that can be of different or the same type.
```{r}
c(1, 2, "a")

barack <- list(age = 59, sex = "M", child.ages = c(22, 19))
class(barack) # list

# accessing elements in the list

barack$age
barack[1] # age value: 59
barack$child.ages
barack$child.ages[1]
barack[[1]] # 59

class(barack[1]) # list
class(barack[[1]]) # first component of the sublist in the first element of the list 
# numeric

serena <- list(age = 39, sex = "F", child.ages = 3)
class(serena) # list

celg <- c(barack, serena) # joins both lists together, elements with the same name would not combine together
celg
celg$sex
celg[1] # first element in the celg list
celg[3]
celg[4]
```



Dataframes are a tightly coupled collection of variables that share many of the properties of matrices and lists and is the fundamental data structure that will be used in most of this course.
```{r}
A <- data.frame(names = c("barack", "serena"), ages = c(58, 39), children = c(2, 1))
A

A$names
class(A) # dataframe
class(A$ages) # numeric

A$spouse = c("michel", "alexis")

A
```

Dyplr and tibble ... not covered now but good to know

```{r}
library(tidyverse)
starwars
class(starwars)
starwars 

starwars %>% dim()
#starwars %>% summary()

starwars %>% select(mass) %>% summary()

starwars %>% filter(sex=="female")


starwars %>% arrange(height,mass)

starwars %>% arrange(desc(height))

starwars %>% slice_head(n=3)

```
